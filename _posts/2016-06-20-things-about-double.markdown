---
layout:     post
title:      "double二三事"
subtitle:   ""
# date:       2016-06-20 10:23:36
author:     "K.I.S.S."
#header-img: ""
catalog:    true
tags:
    - JAVA
---

## 0 一篇一句

“你觉得你花几天时间，研究double，值得吗？” ——by 某同学    
“当然值得，而且是超值！” ——by 我

## 1 概述

double是我们编程中经常会遇到的浮点类型。关于double，你真的了解了吗？    
本文，将总结编程中可能会遇到的double相关的问题。

首先，描述了写这篇博客的原因。    
接着，double相关的几个方面进行介绍

- double的结构
- double的值
- double的比较
- double的舍入
- double的类型转换

最后，搜集和总结了double相关的一些问题

## 2 缘由

#### 2.1 印象中的浮点数

之前，对浮点数只是有个大概的印象。    

1. 不能使用 == 判断相等（[浮点判等的笑话——北邮电梯计划](http://bbs.cloud.icybee.cn/article/Picture/2812786)）
2. 判断相等的方法，Math.abs(a-b) < 0.000001。精确到小数点后多少位。

#### 2.2 刷题遇浮点，坑

最近刷题，遇到一个[【二进制表示（Binary Representation）】](http://www.lintcode.com/en/problem/binary-representation/)。

> 题目描述：给定一个数将其转换为二进制（均用字符串表示），如果这个数的小数部分不能在 32 个字符之内来精确地表示，则返回 "ERROR"。  

我的分析：小数部分最后一个数不为5（不能用2^n的和表示，出现循环，一定超过32位），或者小数部分超过32位（2^n中一定有一个n超过32位），则一定返回“ERROR”。

根据我的分析并写完代码以后，有两个测试用例，跟我的想法有偏差，[详见《\[Lintcode\] Binary Representation》](/2016/06/20/lintcode-binary-representation/#ID5)中的 **5 遇到的问题**。

#### 2.3 浮点坑的结论

结论是：**double Double.parseDouble(String str)，String转double会损失精度** ，详见[《\[Lintcode\] Binary Representation》](/2016/06/20/lintcode-binary-representation/#ID6)中的 **6 结论**。

为求甚解，于是，进一步了解和总结写出本文。

## 3 double的几个方面

#### 3.1 double的结构

###### **表3-1-1 double的组成格式表**

|---
| 部分 | 符号位（Sign） | 指数（Exponent） | 有效数字（Fraction）
|-|-|-|-
| 长度 | 1，第63位 | 11，第62至52位 | 52，第51至0位
| 解释 | 0为正，1为负 | 偏正值（实际大小+1023） | 具体数值

如上表所示，参考[IEEE二进制浮点数算术标准](https://en.wikipedia.org/wiki/IEEE_floating_point)，    
**double由三部分组成：1位符号位 + 11位指数位 + 52位数值位**

![DoubleStructure](/img/in-post/post-things-about-double/double-structure.png)

> Q1：为什么需要使用偏正值（无符号数），而不在指数部分使用补码？    
> A：方便比较大小。如果，指数采用补码标识，则全体符号位S和Exp自身的符号位，将导致不能简单的进行大小比较。   

> **实际大小（实际指数） = 偏正值 - 偏移值**    
> **偏移值 = 2 ^ (n - 1) - 1，n为指数的位数**

----------

#### 3.2 double的值

###### 3.2.1 十进制转double（二进制）

手动把15070 **.** 3转成double（二进制形式） *注：短横线为了方便阅读，不是减号*

1. 先转整数部分
    - 15070使用 **除16取余法，并倒序** 得到 0x3ADE
    - 0x3ADE = 11-1010-1101-1110 (2)
2. 再转小数部分
    - 0 **.** 3 = 0 **.** 010-0110-0110-0110-0110 ...
3. 把两部分合起来
    - 11-1010-1101-1110.010-0110-0110-0110 ...
    - 转成规约数，1 **.** 1101-0110-1111-0010-0110-0110-0110 ... * 2 ^ (13)
4. 把规约数，按照双精度浮点数规范，进行转换
    - 符号位，正数为0
    - 指数（偏正值） = 实际指数 + 偏移值 = 13 + 1023 = 1036，即 100-0000-1100
    - 尾数，规约数默认为1 **.** FFF...FFF。所以，从 3 中的规约数的小数点后面取52位即可。
    - 尾数1101-0110-1111-0010-0110-0110-0110-0110-0110-0110-0110-0110-0110-0110
5. 把符号位、指数和尾数组成double
    - 0  10000001100  1101011011110010011001100110011001100110011001100110

###### 3.2.2 double（二进制）转十进制

手动把 0  10000001100  1101011011110010011001100110011001100110011001100110 转成十进制形式

1. 符号位为0，所以是正数
2. 指数域，10000001100（2）=1036，实际指数 = 1036 - 1023 = 13
3. 规约数为，1 **.** FFF...FFF的形式，即 1 **.** 尾数
    - 1 **.** 1101011011110010011001100110011001100110011001100110
4. 结果 = 规约数 * 2 ^ (实际指数)，即
    - 1 **.** 1101011011110010011001100110011001100110011001100110 * 2^13 = 15070 **.** 3

###### **表3-2-1 double的各种极值情况表**

|---
| 类别 | 符号 | 实际指数 | 有偏移指数 | 指数域 | 尾数域 | 数值
|-|-|-|-|-|-
| 正零 | 0 | -1023 | 0 | 全为0 | 全为0 | 0.0
| 负零 | 1 | -1023 | 0 | 全为0 | 全为0 | -0.0
| 最小非规约数 | * | -1022 | 0 | 全为0 | 51个0+1个1 | [见表3-2-3](#valueDetail)
| 最大非规约数 | * | -1022 | 0 | 全为0 | 52个1 | [见表3-2-3](#valueDetail)
| 正无穷 | 0 | 1024 | 2047 | 全为1 | 全为0 | +∞
| 负无穷 | 1 | 1024 | 2047 | 全为1 | 全为0 | −∞
| NaN | * | 1024 | 2047 | 全为1 | 非零 | NaN
| 最小的规约数 | * | -1022 | 1 | 10个0+1个1 | 52个0 | [见表3-2-3](#valueDetail)
| 最大的规约数 | * | 1023 | 2046 | 10个1+1个0 | 52个1 | [见表3-2-3](#valueDetail)

_注：* 符号位可以为0或者1，NaN表示不是一个数_

> Q1：规约数和非规约数是什么？    
> A：规约数，指数属于[1,2046]，尾数属于[1,2)为1.FFFF...FFFF（规约成1.xxx）    
>    非规约数，指数为0，尾数的属于(0，1)为0.FFFF...FFFF

> Q2：为什么规约数的指数部分全是0，但是，实际指数为-1022。为什么不是-1023？    
> A：IEEE 754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值大1

###### **表3-2-2 double的数值结构表**

|---
| 类别 | 计算结构
|-|-
| 非规约数 | ±0.FFFF...FFFF * 2 ^ (EEE...EEE - 1023 + 1)
| 规约数 | ±1.FFFF...FFFF * 2 ^ (EEE...EEE - 1023)

###### **表3-2-3 double的数值计算详情表** {#valueDetail}

|---
| 类别 | 计算式 | 约等值
|-|-|-
| 最小非规约数 | 2 ^ (-52) * 2 ^ (-1022) | ≈ 4.9E-324
| 最大非规约数 | (1 - 2 ^ (-52)) * 2 ^ (-1022) | ≈ 2.225073858507201E-308
| 最小规约数 | (1 + 0) * 2 ^ (-1022) | ≈ 2.2250738585072014E-308
| 最大规约数 | (1 + 1 - 2 ^ (-52)) * 2 ^ (1023) | ≈ 1.7976931348623157E308


#### 3.3 double的比较 {#ID3-3}

**比较规则**

基本可以按照符号位、指数域、尾数域的顺序作字典比较    

- 非零的正数 > 非零的负数 （符号位）
- 指数域较大数的绝对值 > 指数域较小数的绝对值 （指数域）
- 尾数域较大数的绝对值 > 尾数域较小数的绝对值 （尾数域）

**不同类型的数，在数轴上的分布**

![DoublePosition](/img/in-post/post-things-about-double/double-position.png)

-Inf < 负的规约数 < 负的非规约数 < -0.0 = 0.0 < 正的非规约数 < 正的规约数 < Inf    
 *特殊比较：-Inf = -Inf, Inf = Inf, NaN与任何浮点数（包括自身）的比较结果都为假*

**Java的double比较方法**

- 直接使用 > 或者 <
    + a > b
    + a < b
    + Math.abs(a - b) < 0.000001
- 使用Double.compare(double d1, double d2)
    + Double.compare(d1,d2) > 0
    + Double.compare(d1,d2) < 0
    + Double.compare(d1,d2) == 0
- Double类的实例方法，d1.compareTo(d2)，d1.equals(d2)
    + d1.compareTo(d2) > 0
    + d1.compareTo(d2) < 0
    + d1.compareTo(d2) == 0, d1.equals(d2)

#### 3.4 double的舍入

任何有效数上的运算结果，通常都存放在较长的寄存器中，    
当结果被放回浮点格式时，必须将多出来的比特丢弃。    

IEEE标准的4种方法：

- 舍入到最近，偶数优先（0结尾）
- 朝+∞方向舍入
- 朝-∞方向舍入
- 朝0方向舍入


#### 3.5 double的类型转换

|---
| 类型 | 其他转double | double转其他
|-|-|-
| String | Double.parseDouble(str) | Double.toString(d)
| int | (double) i | (int) d
| char | (double) c | (char) d
| float | (double) f | (float) d

## 4 double相关的问题

1. double为什么不精确？
    - 10进制小数，无法用二进制小数来精确表达。[详见](http://gold.xitu.io/entry/575543857db2a2006993114e)
2. double怎么判等?
    - Double.compare(d1,d2) == 0。[详见](#ID3-3)
3. [为什么Double.MIN_VALUE是正数？](http://bbs.cloud.icybee.cn/article/Java/51063)
    - Double.MIN_VALUE表示：最小的正double（最小的非规约数）
    - double中，最小的是负无穷。其次，是负的最大规约数。[详见](#ID3-3)
4. [double强制转为int，超过int范围的时候，规则是怎样的？](http://bbs.cloud.icybee.cn/article/Java/40040)
    - 大于int最大值，则转成int后变成2147483647
    - 小于int最小值，则转成int后变成-2147483648
5. [System.out.println(15070.3 - 7600.0)输出7470.299999999999，而不是7470.3](http://bbs.cloud.icybee.cn/article/Java/47757)
    - 请查看暖神(nuanyangyang)的回复
6. 在程序中，跟 **钱** 相关的运算，使用什么类型？
    - 使用BigDecimal，[详见](http://stackoverflow.com/questions/8148684/what-is-the-best-data-type-to-use-for-money-in-java-app)

## 5 参考

【维基百科】IEEE754标准。[英文](https://en.wikipedia.org/wiki/IEEE_floating_point)，[中文](https://zh.wikipedia.org/wiki/IEEE_754)    
[【北邮人论坛】为什么Double.MIN_VALUE设计为正数？](http://bbs.cloud.icybee.cn/article/Java/51063)    
[【北邮人论坛】double强制类型转换为int的实现过程](http://bbs.cloud.icybee.cn/article/Java/40040)    
[【北邮人论坛】double计算，看不明白，请教！](http://bbs.cloud.icybee.cn/article/Java/47757)
